# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/08_update.ipynb.

# %% auto 0
__all__ = ['UpdateModule', 'UpdatePlugin', 'TopKDiscreteUpdate', 'TopKContinuousUpdate', 'RLUpdate']

# %% ../nbs/08_update.ipynb 3
from .imports import *
from .utils import whiten
from .module import Module
from .schemas import Item, Query, Batch, UpdateFunction

# %% ../nbs/08_update.ipynb 4
class UpdateModule(Module):
    def __init__(self, function: UpdateFunction):
        super().__init__(Query, function)
        
    def gather_inputs(self, batch: Batch) -> (List[Tuple], List[Query]):
        idxs, inputs = batch.flatten_queries()
        return (idxs, inputs)
    
    def __call__(self, batch: Batch) -> Batch:
        
        idxs, inputs = self.gather_inputs(batch)
        new_queries = self.function(inputs)
        new_queries = self.validate_schema(new_queries)
        return Batch(queries=new_queries)

# %% ../nbs/08_update.ipynb 8
class UpdatePlugin():
    def __call__(self, inputs: List[Query]) -> List[Query]:
        pass

# %% ../nbs/08_update.ipynb 9
class TopKDiscreteUpdate(UpdatePlugin):
    def __init__(self, k: int):
        self.k = k
        
    def __call__(self, inputs: List[Query]) -> List[Query]:
        outputs = []
        
        for query in inputs:
            result_scores = np.array([i.score for i in query.valid_results()])
            topk_idxs = result_scores.argsort()[::-1][:self.k]
            top_items = [query[i] for i in topk_idxs]
            outputs += top_items
            
        outputs = [Query.from_item(i) for i in outputs]
        return outputs

# %% ../nbs/08_update.ipynb 11
class TopKContinuousUpdate():
    def __init__(self, k: int):
        self.k = k
        
    def __call__(self, inputs: List[Query]) -> List[Query]:
        outputs = []
        
        for query in inputs:
            result_scores = np.array([i.score for i in query.valid_results()])
            topk_idxs = result_scores.argsort()[::-1][:self.k]
            topk_embs = np.array([query[i].embedding for i in topk_idxs])
            
            new_embedding = np.average(topk_embs, 0)
            output = Query.from_parent_query(embedding=new_embedding, parent_query=query)
            outputs.append(output)
        return outputs

# %% ../nbs/08_update.ipynb 13
class RLUpdate():
    def __init__(self,
                 lrs: Union[List[float], np.ndarray],
                 distance_penalty: float
                ):
        self.lrs = np.array(lrs)
        self.distance_penalty = distance_penalty
        
    def __call__(self, queries: List[Query]) -> List[Query]:
        query_embeddings = np.array([i.embedding for i in queries])
        
        result_embeddings = [np.array([i.embedding for i in query.valid_results()]) 
                             for query in queries]
        
        advantages = [whiten(np.array([i.score for i in query.valid_results()])) 
                      for query in queries]

        advantage_grad = np.array(
                        [(advantages[i][:,None] * (2*(query_embeddings[i,None] - result_embeddings[i]))).mean(0)
                        for i in range(len(queries))])

        distance_grad = 2*(query_embeddings - np.array([i.mean(0) for i in result_embeddings]))

        grads = advantage_grad + (self.distance_penalty * distance_grad)

        new_embeddings = query_embeddings[:,None] - (grads[:,None,:] * self.lrs[None,:,None])
        # (n,m,-1) = (n,1,-1) - ((n,1,-1) * (1,m,1))
        
        results = []
        
        for i in range(new_embeddings.shape[0]): # number of embeddings
            for j in range(new_embeddings.shape[1]): # learning rates
                
                new_query = Query.from_parent_query(embedding=new_embeddings[i][j].tolist(), 
                                                    parent_query=queries[i])
                new_query.data['rl_update_details'] = {
                                                        'parent_embedding' : query_embeddings[i].tolist(),
                                                        'lr' : self.lrs[j],
                                                        'grad' : grads[i].tolist(),
                                                    }
                
                results.append(new_query)

        return results
