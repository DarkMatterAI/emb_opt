# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_update.ipynb.

# %% auto 0
__all__ = ['UpdateModule', 'TopKDiscreteUpdate', 'TopKContinuousUpdate', 'RLUpdate']

# %% ../nbs/07_update.ipynb 3
from .imports import *
from .utils import whiten
from .core import Module
from .schemas import (
                            Item, 
                            Query, 
                            Batch, 
                            ContinuousUpdateResponse,
                            UpdateFunction,
                            UpdateResponse,
                            UpdateResponseValidator,
                            )

# %% ../nbs/07_update.ipynb 4
class UpdateModule(Module):
    def __init__(self, function: UpdateFunction):
        super().__init__(UpdateResponseValidator, function)
        
    def validate_schema(self, results: UpdateResponse) -> UpdateResponse:
        results =  self.output_schema.model_validate({'results':results}, strict=True)               
        return results.results
        
    def build_batch(self, results: UpdateResponse) -> Batch:
        if isinstance(results, Batch):
            batch = results
        elif isinstance(results[0], Query):
            batch = Batch(queries=results)
        elif isinstance(results[0], Item):
            batch = Batch(queries=[Query.from_item(i) for i in results])
        elif isinstance(results[0], ContinuousUpdateResponse):
            batch = Batch(queries=[Query.from_parent(i.embedding, i.parent_query) for i in results])
            
        return batch
        
    def __call__(self, batch: Batch) -> Batch:
        results = self.function(batch)
        results = self.validate_schema(results)
        batch = self.build_batch(results)
        return batch

# %% ../nbs/07_update.ipynb 8
class TopKDiscreteUpdate():
    def __init__(self, k):
        self.k = k
        
    def __call__(self, batch: Batch):
        outputs = []
        
        for query in batch:
            result_scores = np.array([i.score for i in query])
            topk_idxs = result_scores.argsort()[::-1][:self.k]
            top_items = [query[i] for i in topk_idxs]
            outputs += top_items
        return outputs

# %% ../nbs/07_update.ipynb 10
class TopKContinuousUpdate():
    def __init__(self, 
                 k: int,
                ):
        self.k = k
        
    def __call__(self, batch: Batch):
        outputs = []
        
        for query in batch:
            result_scores = np.array([i.score for i in query])
            topk_idxs = result_scores.argsort()[::-1][:self.k]
            topk_embs = np.array([query[i].embedding for i in topk_idxs])
            
            new_embedding = np.average(topk_embs, 0)
            
            output = ContinuousUpdateResponse(embedding=new_embedding, parent_query=query)
            outputs.append(output)
        return outputs

# %% ../nbs/07_update.ipynb 12
class RLUpdate():
    def __init__(self,
                 lrs: List[float],
                 distance_penalty: float
                ):
        self.lrs = lrs
        self.distance_penalty = distance_penalty
        
    def __call__(self, batch: Batch) -> List[ContinuousUpdateResponse]:

        query_embeddings = np.array([i.embedding for i in batch])
        result_embeddings = [np.array([i.embedding for i in query]) for query in batch]
        advantages = [whiten(np.array([i.score for i in query])) for query in batch]

        advantage_grad = np.array(
                        [(advantages[i][:,None] * (2*(query_embeddings[i,None] - result_embeddings[i]))).mean(0)
                        for i in range(len(batch))])

        distance_grad = 2*(query_embeddings - np.array([i.mean(0) for i in result_embeddings]))

        grads = advantage_grad + (self.distance_penalty * distance_grad)

        new_embeddings = query_embeddings[:,None] - (grads[:,None,:] * self.lrs[None,:,None])
        
        results = []
        
        for i in range(new_embeddings.shape[0]):
            for j in range(new_embeddings.shape[1]):
                results.append(
                    ContinuousUpdateResponse(embedding=new_embeddings[i][j].tolist(), parent_query=batch[i]))

        return results
