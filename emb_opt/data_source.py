# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/04_data_source.ipynb.

# %% auto 0
__all__ = ['DataSourceModule', 'DataSourcePlugin', 'NumpyDataPlugin', 'HugggingfaceDataPlugin']

# %% ../nbs/04_data_source.ipynb 3
from .imports import *
from .utils import build_batch_from_embeddings
from .module import Module
from .schemas import Item, Query, Batch, DataSourceFunction, DataSourceResponse

# %% ../nbs/04_data_source.ipynb 4
class DataSourceModule(Module):
    def __init__(self, function: DataSourceFunction):
        super().__init__(DataSourceResponse, function)
        
    def gather_inputs(self, batch: Batch) -> (List[Tuple], List[Query]):
        idxs, inputs = batch.flatten_queries()
        return (idxs, inputs)
    
    def scatter_results(self, batch: Batch, idxs: List[Tuple], results: List[DataSourceResponse]):
        for (q_idx, r_idx), result in zip(idxs, results):
            batch_item = batch.get_item(q_idx, r_idx)
            if result.data:
                batch_item.data.update(result.data)
                
            if not result.valid:
                batch_item.update_internal(removed=True, removal_reason='invalid query')
                
            elif len(result.query_results)==0:
                batch_item.update_internal(removed=True, removal_reason='query returned no results')
                
            else:
                batch_item.add_query_results(result.query_results)

# %% ../nbs/04_data_source.ipynb 6
class DataSourcePlugin():
    def __call__(self, inputs: List[Query]) -> List[DataSourceResponse]:
        pass

# %% ../nbs/04_data_source.ipynb 7
class NumpyDataPlugin(DataSourcePlugin):
    def __init__(self,
                 k: int,
                 item_embeddings: np.ndarray,
                 item_data: Optional[List[Dict]]=None,
                 distance_metric: str='euclidean'
                ):
        
        self.k = k
        self.item_embeddings = item_embeddings
        self.item_data = item_data
        self.distance_metric = distance_metric
        
    def __call__(self, inputs: List[Query]) -> List[DataSourceResponse]:
        
        queries = np.array([i.embedding for i in inputs])
        distances = cdist(queries, self.item_embeddings, metric=self.distance_metric)
        topk = distances.argsort(-1)[:, :self.k]
        
        outputs = []
        for i in range(len(inputs)):
            items = []
            query_data = {'query_distance' : []}
            for j in topk[i]:
                data = dict(self.item_data[j]) if self.item_data else {}
                query_data['query_distance'].append(distances[i,j])
                item = Item(embedding=self.item_embeddings[j], data=data)
                items.append(item)
            result = DataSourceResponse(valid=True, data=query_data, query_results=items)
            outputs.append(result)
            
        return outputs

# %% ../nbs/04_data_source.ipynb 9
class HugggingfaceDataPlugin(DataSourcePlugin):
    def __init__(self,
                 k: int,
                 dataset: datasets.Dataset,
                 index_name: str
                ):
        
        self.k = k
        self.dataset = dataset
        self.index_name = index_name
        self.index = self.dataset.get_index(index_name)
        
    def __call__(self, inputs: List[Query]) -> List[DataSourceResponse]:
        queries = np.array([i.embedding for i in inputs])
        
        res = self.index.search_batch(queries, k=self.k)
        distances = res.total_scores
        indices = res.total_indices
        
        outputs = []
        for i in range(indices.shape[0]):
            items = []
            query_data = {'query_distance' : []}
            for j in range(indices.shape[1]):
                query_data['query_distance'].append(distances[i,j])
                
                dataset_index = indices[i, j]
                item_data = dict(self.dataset[int(dataset_index)])
                embedding = item_data.pop(self.index_name)
                
                item = Item(embedding=embedding, data=item_data)
                items.append(item)
                
            result = DataSourceResponse(valid=True, data=query_data, query_results=items)
            outputs.append(result)
            
        return outputs       
