# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/plugins/02_faiss.ipynb.

# %% auto 0
__all__ = ['FaissDataPlugin']

# %% ../../nbs/plugins/02_faiss.ipynb 3
from ..imports import *
from ..schemas import Query, Item, DataSourceResponse
from ..data_source import DataSourcePlugin, DataSourceModule
from ..utils import build_batch_from_embeddings

try:
    import faiss
except:
    warnings.warn('Failed to import faiss library - check package install')

# %% ../../nbs/plugins/02_faiss.ipynb 5
class FaissDataPlugin(DataSourcePlugin):
    '''
    FaissDataPlugin - data plugin for working with 
    a faiss vector index
    
    The data query will run `k` nearest neighbors against 
    `faiss_index`
    
    Optionally, `item_data` can be provided as a list of dicts, where 
    `item_data[i]` corresponds to the data for embedding `i` in the 
    faiss index
    
    If `item_data` is provided `item_data[i]['item_key']` defines the 
    specific value for item `i`
    
    `search_params` are optional kwargs sent to 
    `faiss.SearchParameters`
    '''
    def __init__(self, 
                 k: int,                                               # k nearest neighbors to return
                 faiss_index: faiss.Index,                             # faiss index
                 item_data: Optional[List[Dict]]=None,                 # Optional dict of item data
                 item_key: Optional[str]=None,                         # Optional key for item value (should be in `item_data` dict)
                 search_params: Optional[faiss.SearchParameters]=None  # faiss search params
                ):
        
        self.k = k
        self.faiss_index = faiss_index
        self.item_data = item_data
        self.item_key = item_key
        self.search_params = search_params
        
    def __call__(self, inputs: List[Query]) -> List[DataSourceResponse]:
        query_vectors = np.array([i.embedding for i in inputs])
        
        distances, indices = self.faiss_index.search(query_vectors, self.k, params=self.search_params)
        
        outputs = []
        for query_idx in range(indices.shape[0]):
            result_embeddings = self.faiss_index.reconstruct_batch(indices[query_idx])
            items = []
            query_data = {'query_distance' : []}
            
            for result_idx in range(indices.shape[1]):
                item_id = indices[query_idx, result_idx]
                item_embedding = result_embeddings[result_idx]
                query_distance = distances[query_idx, result_idx]
                
                if item_id != -1:
                    item_data = None
                    item_value = None
                    
                    if self.item_data:
                        item_data = dict(self.item_data[item_id])
                        if self.item_key:
                            item_value = item_data.pop(self.item_key)
                            
                    item = Item(id=item_id,
                                item=item_value,
                                embedding=item_embedding,
                                data=item_data,
                                score=None
                               )
                    items.append(item)
                    query_data['query_distance'].append(query_distance)
                    
            result = DataSourceResponse(valid=bool(items), data=query_data, query_results=items)
            outputs.append(result)
        return outputs
