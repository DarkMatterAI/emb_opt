# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/plugins/02_faiss.ipynb.

# %% auto 0
__all__ = ['FaissDataPlugin']

# %% ../../nbs/plugins/02_faiss.ipynb 3
from ..imports import *
from ..schemas import Query, Item, DataSourceResponse
from ..data_source import DataSourcePlugin, DataSourceModule
from ..utils import build_batch_from_embeddings

try:
    import faiss
except:
    warnings.warn('Failed to import faiss library - check package install')

# %% ../../nbs/plugins/02_faiss.ipynb 5
class FaissDataPlugin(DataSourcePlugin):
    '''
    FaissDataPlugin - data plugin for working with 
    a faiss vector index
    
    The data query will run `k` nearest neighbors against 
    `faiss_index`
    
    Optionally, `item_data` can be provided as a list of dicts, where 
    `item_data[i]` corresponds to the data for embedding `i` in the 
    faiss index
    
    If `item_data` is provided `item_data[i]['item_key']` defines the 
    specific value for item `i`
    
    `search_params` are optional kwargs sent to 
    `faiss.SearchParameters`

    if `distance_cutoff` is specified, query results with a distance 
    greater than `distance_cutoff` are ignored
    '''
    def __init__(self, 
                 k: int,                                                # k nearest neighbors to return
                 faiss_index: faiss.Index,                              # faiss index
                 item_data: Optional[List[Dict]]=None,                  # Optional dict of item data
                 item_key: Optional[str]=None,                          # Optional key for item value (should be in `item_data` dict)
                 search_params: Optional[faiss.SearchParameters]=None,  # faiss search params
                 distance_cutoff: Optional[float]=None                  # query to result distance cutoff
                ):
        
        self.k = k
        self.faiss_index = faiss_index
        self.item_data = item_data
        self.item_key = item_key
        self.search_params = search_params
        self.distance_cutoff = distance_cutoff if distance_cutoff is not None else float('inf')
        
    def __call__(self, inputs: List[Query]) -> List[DataSourceResponse]:
        query_vectors = np.array([i.embedding for i in inputs])
        
        distances, indices = self.faiss_index.search(query_vectors, self.k, params=self.search_params)
        
        outputs = []
        for query_idx in range(indices.shape[0]):
            result_embeddings = self.faiss_index.reconstruct_batch(indices[query_idx])
            items = []
            query_data = {'query_distance' : []}
            
            for result_idx in range(indices.shape[1]):
                distance = distances[query_idx, result_idx]
                
                if distance < self.distance_cutoff:
                    item_id = indices[query_idx, result_idx]
                    item_embedding = result_embeddings[result_idx]

                    if item_id != -1:
                        item_data = None
                        item_value = None

                        if self.item_data:
                            item_data = dict(self.item_data[item_id])
                            if self.item_key:
                                item_value = item_data.pop(self.item_key)

                        item = Item(id=item_id,
                                    item=item_value,
                                    embedding=item_embedding,
                                    data=item_data,
                                    score=None
                                   )
                        items.append(item)
                        query_data['query_distance'].append(distance)
                    
            result = DataSourceResponse(valid=bool(items), data=query_data, query_results=items)
            outputs.append(result)
        return outputs
