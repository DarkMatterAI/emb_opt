# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_query_update.ipynb.

# %% auto 0
__all__ = ['QueryUpdate', 'RLUpdate', 'KNNUpdate']

# %% ../nbs/02_query_update.ipynb 3
from .imports import *
from .utils import pack_dataset, whiten
from .backends.hf import HFDatabase
from .core import Score

# %% ../nbs/02_query_update.ipynb 4
class QueryUpdate():
    def __call__(self, query_vectors: np.ndarray, query_dataset: Dataset) -> np.ndarray:
        return query_vectors

# %% ../nbs/02_query_update.ipynb 5
class RLUpdate(QueryUpdate):
    def __init__(self, lr: float):
        self.lr = lr
        
    def __call__(self, query_vectors: np.ndarray, query_dataset: Dataset) -> np.ndarray:
        
        packed_dict = pack_dataset(query_dataset, 'query_idx', ['embedding', 'score'])
        grads = []
        
        for query_idx in range(query_vectors.shape[0]):
            embs = np.array(packed_dict[query_idx]['embedding'])
            scores = np.array(packed_dict[query_idx]['score'])

            advantages = whiten(scores)
            grad = (advantages[:,None] * (2*(query_vectors[query_idx][None] - embs))).mean(0)
            grads.append(grad)

        grads = np.array(grads)
        updated_query_vectors = query_vectors - self.lr*grads
        return updated_query_vectors

# %% ../nbs/02_query_update.ipynb 7
class KNNUpdate(QueryUpdate):
    def __init__(self, k: int, score_weighting: bool=True):
        self.k = k
        self.score_weighting = score_weighting
        
    def __call__(self, query_vectors: np.ndarray, query_dataset: Dataset) -> np.ndarray:
        
        packed_dict = pack_dataset(query_dataset, 'query_idx', ['embedding', 'score'])
        new_queries = []
        
        for query_idx in range(query_vectors.shape[0]):
            embs = np.array(packed_dict[query_idx]['embedding'])
            scores = np.array(packed_dict[query_idx]['score'])

            topk_idxs = scores.argsort()[::-1][:self.k]
            topk_embs = embs[topk_idxs]
            topk_scores = scores[topk_idxs]

            if self.score_weighting:
                new_queries.append(np.average(topk_embs, 0, weights=topk_scores))
            else:
                new_queries.append(np.average(topk_embs, 0))

        query_vectors = np.array(new_queries)
        
        return query_vectors
