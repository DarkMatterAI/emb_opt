# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_schemas.ipynb.

# %% auto 0
__all__ = ['DataSourceFunction', 'FilterFunction', 'ScoreFunction', 'PruneFunction', 'UpdateFunction', 'InteralData', 'Item',
           'Query', 'Batch', 'DataSourceResponse', 'FilterResponse', 'ScoreResponse', 'PruneResponse', 'UpdateResponse']

# %% ../nbs/00_schemas.ipynb 3
from .imports import *

# %% ../nbs/00_schemas.ipynb 7
class InteralData(BaseModel):
    'Internal Data Tracking'
    removed: bool                 # if item/query has been removed by some step
    removal_reason: Optional[str] # reason for removal
    parent_id: Optional[str]      # parent query of item/query
    collection_id: Optional[int]  # collection id of item/query
    iteration: Optional[int]      # current iteration

# %% ../nbs/00_schemas.ipynb 9
class Item(BaseModel, extra='allow'):
    id: Optional[Union[str, int]] # id/index of item
    item: Optional[Any]           # the item itself
    embedding: List[float]        # embedding representing the item
    score: Optional[float]        # item score
    data: Optional[dict]          # any other associated data
    
    @model_validator(mode='after')
    def _fill_internal(self):
        if not hasattr(self, 'internal'):
            self.internal = InteralData(
                                    removed=False, 
                                    removal_reason=None,
                                    parent_id=None, 
                                    collection_id=None,
                                    iteration=None
                                    )
        
        if self.data is None:
            self.data = {}
            
        if self.id is None:
            self.id = f'item_{str(uuid.uuid1())}'
            
        return self
    
    def update_internal(self, **kwargs):
        self.internal.__dict__.update(kwargs)
        
    @classmethod
    def from_minimal(cls, 
                     id: Optional[Union[str, int]]=None, 
                     item: Optional[Any]=None, 
                     embedding: List[float]=None, 
                     score: Optional[float]=None, 
                     data: Optional[dict]=None):
        'convenience function for creating an `Item` with default `None` values'
        return cls(id=id, item=item, embedding=embedding, score=score, data=data)

# %% ../nbs/00_schemas.ipynb 12
class Query(BaseModel, extra='allow'):
    item: Optional[Any]                  # Optional item associated with query
    embedding: List[float]               # Query embedding
    data: Optional[dict]                 # data associated with the query
    query_results: Optional[list[Item]]  # list of `Item` query results
        
    def __iter__(self):
        return iter(self.query_results)

    def __getitem__(self, idx: int):
        return self.query_results[idx]
    
    def __len__(self):
        return len(self.query_results)
    
    def valid_results(self) -> Item:
        '''
        iterates over `self.query_results`, skipping results 
        with `internal.removed=True`
        '''
        for result in self.query_results:
            if not result.internal.removed:
                yield result
    
    def enumerate_query_results(self, skip_removed: bool=True) -> (int, Item):
        '''
        enumerates over `self.query_results`. if `skip_removed=True`,
        results with `internal.removed=True` are ignored
        '''
        for i, result in enumerate(self.query_results):
            if skip_removed:
                if not result.internal.removed:
                    yield (i, result)
            else:
                yield (i, result)
    
    @model_validator(mode='after')
    def _fill_internal(self):
        if not hasattr(self, 'internal'):
            self.internal = InteralData(
                                        removed=False, 
                                        removal_reason=None,      
                                        parent_id=None, 
                                        collection_id=None,
                                        iteration=None
                                    )
            
        if not hasattr(self, 'id'):
            self.id = f'query_{str(uuid.uuid1())}'
        
        if self.query_results is None:
            self.query_results = []
            
        if self.data is None:
            self.data = {}
            
        return self
                
    @classmethod
    def from_item(cls, item: Item):
        '''
        creates a `Query` from an input `Item`. The `item`, `embedding`, and `data` 
        attributes from the `Item` are propagated to the `Query`, as well as the 
        item's parent query ID
        '''
        query = cls(item=item.item, embedding=item.embedding, data=item.data, query_results=None)
        query.data['_source_item_id'] = item.id
        query.update_internal(parent_id=item.internal.parent_id, 
                              collection_id=item.internal.collection_id)
        return query
    
    @classmethod
    def from_parent_query(cls, embedding: List[float], parent_query):
        '''
        creates a `Query` from an input `embedding` and a parent `Query`. The new
        `Query` is created from the `embedding` and assigned the `parent_query` ID as 
        the parent ID
        '''
        query = cls(item=None, embedding=embedding, data={}, query_results=None)
        query.update_internal(parent_id=parent_query.id, 
                              collection_id=parent_query.internal.collection_id)
        return query
    
    def add_query_results(self, query_results: List[Item]) -> None:
        '''
        Adds query results and propagates query parent information to them
        '''
        for result in query_results:
            result.update_internal(parent_id=self.id, 
                                   collection_id=self.internal.collection_id, 
                                   iteration=self.internal.iteration)
            self.query_results.append(result)
    
    def update_internal(self, **kwargs):
        self.internal.__dict__.update(kwargs)
        if (len(self.query_results)>0) and (len(list(self.valid_results()))==0):
            self.internal.__dict__.update({'removed':True, 'removal_reason':'all query results removed'})
            
    @classmethod
    def from_minimal(cls, 
                     item: Optional[Any]=None, 
                     embedding: List[float]=None, 
                     data: Optional[dict]=None,
                     query_results: Optional[List[Item]]=None
                    ):
        'convenience function for creating an `Query` with default `None` values'
        return cls(item=item, embedding=embedding, data=data, query_results=query_results)

# %% ../nbs/00_schemas.ipynb 20
class Batch(BaseModel):
    queries: List[Query]
        
    def __iter__(self):
        return iter(self.queries)

    def __getitem__(self, idx: int):
        return self.queries[idx]
    
    def __len__(self):
        return len(self.queries)
    
    def get_item(self, 
                 query_index: int, 
                 result_index: Optional[int]=None) -> Union[Query, Item]:
        '''
        Selects an item from the batch.
        
        If `result_index=None`, returns the `Query` found at `self.queries[query_index]`
        
        Otherwise, returns the `Item` found at `self.queries[query_index][result_index]`
        '''
        if result_index is not None:
            return self.queries[query_index][result_index]
        else:
            return self.queries[query_index]
        
    def valid_queries(self) -> Query:
        'Iterates over valid queries'
        for query in self.queries:
            if not query.internal.removed:
                yield query
        
    def enumerate_queries(self, skip_removed=True) -> (Tuple[int, None], Query):
        '''
        enumerates over `self.queries`. if `skip_removed=True`,
        queries with `internal.removed=True` are ignored
        '''
        for i, query in enumerate(self.queries):
            if skip_removed:
                if not query.internal.removed:
                    yield ((i,None), query)
            else:
                yield ((i,None), query)
                
    def enumerate_query_results(self, skip_removed=True) -> (Tuple[int, int], Item):
        '''
        enumerates over results contained in `self.queries`. 
        if `skip_removed=True`, results with `internal.removed=True` 
        are ignored
        '''
        for (i,_), query in self.enumerate_queries(skip_removed):
            for j, result in query.enumerate_query_results(skip_removed):
                yield ((i,j), result)

                
    def flatten_queries(self, skip_removed=True) -> (List[Tuple[int, None]], List[Query]):
        '''
        flattens `self.queries`, returing a list of index values and 
        a list of queries.
        
        if `skip_removed=True`, queries with `internal.removed=True` 
        are ignored
        '''
        idxs = []
        outputs = []
        for i, q in self.enumerate_queries(skip_removed):
            idxs.append(i)
            outputs.append(q)
        return idxs, outputs
                
    def flatten_query_results(self, skip_removed=True) -> (List[Tuple[int, int]], List[Item]):
        '''
        flattens results contained in `self.queries`, 
        returing a list of index values and a list of items.
        
        if `skip_removed=True`, results with `internal.removed=True` 
        are ignored
        '''
        idxs = []
        outputs = []
        for i, r in self.enumerate_query_results(skip_removed):
            idxs.append(i)
            outputs.append(r)
        return idxs, outputs

# %% ../nbs/00_schemas.ipynb 26
class DataSourceResponse(BaseModel):
    valid: bool                       # if input `Query` was valid (if False, associated `Query` is removed)
    data: Optional[Dict]              # optional dict of data associated with the query
    query_results: List[Item]         # list of `Item` results

# %% ../nbs/00_schemas.ipynb 27
DataSourceFunction = Callable[List[Query], List[DataSourceResponse]]

# %% ../nbs/00_schemas.ipynb 29
class FilterResponse(BaseModel):
    valid: bool           # if the input `Item` is valid (if False, associated `Item` is removed)
    data: Optional[Dict]  # optional dict of data associated with the filter response

# %% ../nbs/00_schemas.ipynb 30
FilterFunction = Callable[List[Item], List[FilterResponse]]

# %% ../nbs/00_schemas.ipynb 32
class ScoreResponse(BaseModel):
    valid: bool             # if the input `Item` is valid (if False, associated `Item` is removed)
    score: Optional[float]  # the score of the input `Item`. Can be `None` if `valid=False`
    data: Optional[Dict]    # optional dict of data associated with the score response

# %% ../nbs/00_schemas.ipynb 33
ScoreFunction = Callable[List[Item], List[ScoreResponse]]

# %% ../nbs/00_schemas.ipynb 35
class PruneResponse(BaseModel):
    valid: bool           # if the input `Query` item is valid (if False, the associated `Query` is removed)
    data: Optional[Dict]  # optional dict of data associated with the prune response

# %% ../nbs/00_schemas.ipynb 36
PruneFunction = Callable[List[Query], List[PruneResponse]]

# %% ../nbs/00_schemas.ipynb 38
class UpdateResponse(BaseModel):
    query: Query                # the new `Query`
    parent_id: Optional[str]    # optional parent query ID, used for tracking query progression

# %% ../nbs/00_schemas.ipynb 39
UpdateFunction = Callable[List[Query], List[UpdateResponse]]
