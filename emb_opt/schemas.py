# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_schemas.ipynb.

# %% auto 0
__all__ = ['DataSourceFunction', 'FilterFunction', 'ScoreFunction', 'PruneFunction', 'UpdateFunction', 'InteralData', 'Item',
           'Query', 'Batch', 'DataSourceResponse', 'FilterResponse', 'ScoreResponse', 'PruneResponse']

# %% ../nbs/00_schemas.ipynb 3
from .imports import *

# %% ../nbs/00_schemas.ipynb 5
class InteralData(BaseModel):
    id: str
    removed: bool
    removal_reason: Optional[str]
    parent_id: Optional[str]
    collection_id: Optional[int]
        
    @model_validator(mode='before')
    @classmethod
    def _fill_data(cls, inputs: Any) -> Any:
        if isinstance(inputs, BaseModel):
            inputs = inputs.model_dump()
            
        if inputs.get('id', None) is None:
            inputs['id'] = str(uuid.uuid1())
            
        if inputs.get('removal_reason', None) is None:
            inputs['removal_reason'] = ''
            
        return inputs

# %% ../nbs/00_schemas.ipynb 6
class Item(BaseModel):
    item: Optional[str]
    embedding: List[float]
    score: Optional[float]
    data: Optional[dict]
    internal: Optional[InteralData]
        
    @model_validator(mode='before')
    @classmethod
    def _fill_data(cls, inputs: Any) -> Any:
        if isinstance(inputs, BaseModel):
            inputs = inputs.model_dump()

        if inputs.get('data', None) is None:
            inputs['data'] = {}
            
        if inputs.get('internal', None) is None:
            inputs['internal'] = InteralData(id=None, removed=False, 
                                           parent_id=None, collection_id=None)

        if inputs.get('score', None) is None:
            inputs['score'] = None

        if inputs.get('item', None) is None:
            inputs['item'] = None

        return inputs
    
    def update_internal(self, **kwargs):
        self.internal.__dict__.update(kwargs)

# %% ../nbs/00_schemas.ipynb 7
class Query(BaseModel):
    item: Optional[str]
    embedding: Optional[List[float]]
    data: Optional[dict]
    query_results: Optional[list[Item]]
    internal: Optional[InteralData]
        
    def __iter__(self):
        return iter(self.query_results)

    def __getitem__(self, idx: int):
        return self.query_results[idx]
    
    def __len__(self):
        return len(self.query_results)
    
    def valid_results(self):
        for result in self.query_results:
            if not result.internal.removed:
                yield result
    
    def enumerate_query_results(self, skip_removed=True):
        for i, result in enumerate(self.query_results):
            if skip_removed:
                if not result.internal.removed:
                    yield (i, result)
            else:
                yield (i, result)
        
    @model_validator(mode='before')
    @classmethod
    def _fill_data(cls, inputs: Any) -> Any:
        if isinstance(inputs, BaseModel):
            inputs = inputs.model_dump()
                        
        if inputs.get('data', None) is None:
            inputs['data'] = {}
            
        if inputs.get('internal', None) is None:
            inputs['internal'] = InteralData(id=str(uuid.uuid1()), removed=False, 
                                           parent_id=None, collection_id=None)
        
        if inputs.get('query_results', None) is None:
            inputs['query_results'] = []
            
        if inputs.get('item', None) is None:
            inputs['item'] = None

        return inputs
                
    @classmethod
    def from_item(cls, item: Item):
        inputs = {
            'item' : item.item,
            'embedding' : item.embedding,
            'data' : item.data,
            'query_results' : [],
            'internal' : {
                'id' : None,
                'removed' : False,
                'parent_id' : item.internal.id,
                'collection_id' : item.internal.collection_id
            }
        }
        return cls(**inputs)
    
    @classmethod
    def from_parent_query(cls, embedding: List[float], parent_query):
        inputs = {
            'embedding' : embedding,
            'internal' : {
                'id' : None,
                'removed' : False,
                'parent_id' : parent_query.internal.id,
                'collection_id' : parent_query.internal.collection_id
            }
        }
        
        return cls(**inputs)
    
    def add_query_results(self, query_results: List[Item]):
        
        parent_id = self.internal.id
        collection_id = self.internal.collection_id
        for result in query_results:
            result.update_internal(parent_id=parent_id, collection_id=collection_id)
            self.query_results.append(result)
    
    def update_internal(self, **kwargs):
        self.internal.__dict__.update(kwargs)
        if (len(self.query_results)>0) and (len(list(self.valid_results()))==0):
            self.internal.__dict__.update({'removed':True, 'removal_reason':'all query results removed'})

# %% ../nbs/00_schemas.ipynb 9
class Batch(BaseModel):
    queries: List[Query]
        
    def __iter__(self):
        return iter(self.queries)

    def __getitem__(self, idx: int):
        return self.queries[idx]
    
    def __len__(self):
        return len(self.queries)
    
    def get_item(self, query_index, result_index=None):
        if result_index is not None:
            return self.queries[query_index][result_index]
        else:
            return self.queries[query_index]
        
    def enumerate_queries(self, skip_removed=True):
        for i, query in enumerate(self.queries):
            if skip_removed:
                if not query.internal.removed:
                    yield ((i,None), query)
            else:
                yield ((i,None), query)
                
    def enumerate_query_results(self, skip_removed=True):
        for (i,_), query in self.enumerate_queries(skip_removed):
            for j, result in query.enumerate_query_results(skip_removed):
                yield ((i,j), result)

                
    def flatten_queries(self, skip_removed=True):
        idxs = []
        outputs = []
        for i, q in self.enumerate_queries(skip_removed):
            idxs.append(i)
            outputs.append(q)
        return idxs, outputs
                
    def flatten_query_results(self, skip_removed=True):
        idxs = []
        outputs = []
        for i, r in self.enumerate_query_results(skip_removed):
            idxs.append(i)
            outputs.append(r)
        return idxs, outputs

# %% ../nbs/00_schemas.ipynb 12
class DataSourceResponse(BaseModel):
    valid: bool
    data: Optional[Dict]
    query_results: List[Item]

# %% ../nbs/00_schemas.ipynb 13
DataSourceFunction = Callable[List[Query], List[DataSourceResponse]]

# %% ../nbs/00_schemas.ipynb 15
class FilterResponse(BaseModel):
    valid: bool
    data: Optional[dict]
        
    @model_validator(mode='before')
    @classmethod
    def _fill_data(cls, data: Any) -> Any:
        if "data" not in data:
            data["data"] = None
        return data

# %% ../nbs/00_schemas.ipynb 16
FilterFunction = Callable[List[Item], List[FilterResponse]]

# %% ../nbs/00_schemas.ipynb 18
class ScoreResponse(BaseModel):
    valid: bool
    score: Optional[float]
    data: Optional[dict]
        
    @model_validator(mode='before')
    @classmethod
    def _fill_data(cls, data: Any) -> Any:
        if "data" not in data:
            data["data"] = None
        return data

# %% ../nbs/00_schemas.ipynb 19
ScoreFunction = Callable[List[Item], List[ScoreResponse]]

# %% ../nbs/00_schemas.ipynb 21
class PruneResponse(BaseModel):
    valid: bool
    data: Optional[dict]
        
    @model_validator(mode='before')
    @classmethod
    def _fill_data(cls, data: Any) -> Any:
        if "data" not in data:
            data["data"] = None
        return data

# %% ../nbs/00_schemas.ipynb 22
PruneFunction = Callable[List[Query], List[PruneResponse]]

# %% ../nbs/00_schemas.ipynb 24
UpdateFunction = Callable[List[Query], List[Query]]
