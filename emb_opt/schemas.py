# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_schemas.ipynb.

# %% auto 0
__all__ = ['DataSourceFunction', 'FilterFunction', 'ScoreFunction', 'PruneFunction', 'UpdateFunction', 'InteralData', 'Item',
           'Query', 'Batch', 'DataSourceResponse', 'FilterResponse', 'ScoreResponse', 'PruneResponse']

# %% ../nbs/00_schemas.ipynb 3
from .imports import *
# from pydantic import Extra

# %% ../nbs/00_schemas.ipynb 5
class InteralData(BaseModel):
    removed: bool
    removal_reason: Optional[str]
    parent_id: Optional[str]
    collection_id: Optional[int]
    iteration: Optional[int]

# %% ../nbs/00_schemas.ipynb 6
class Item(BaseModel, extra='allow'):
    id: Optional[Union[str, int]]
    item: Optional[Any]
    embedding: List[float]
    score: Optional[float]
    data: Optional[dict]
    
    @model_validator(mode='after')
    def _fill_internal(self):
        if not hasattr(self, 'internal'):
            self.internal = InteralData(
                                    removed=False, 
                                    removal_reason=None,
                                    parent_id=None, 
                                    collection_id=None,
                                    iteration=None
                                    )
        
        if self.data is None:
            self.data = {}
            
        if self.id is None:
            self.id = f'item_{str(uuid.uuid1())}'
            
        return self
    
    def update_internal(self, **kwargs):
        self.internal.__dict__.update(kwargs)
        
    @classmethod
    def from_minimal(cls, id=None, item=None, embedding=None, score=None, data=None):
        return cls(id=id, item=item, embedding=embedding, score=score, data=data)

# %% ../nbs/00_schemas.ipynb 8
class Query(BaseModel, extra='allow'):
    id: Optional[Union[str, int]]
    item: Optional[Any]
    embedding: List[float]
    data: Optional[dict]
    query_results: Optional[list[Item]]
        
    def __iter__(self):
        return iter(self.query_results)

    def __getitem__(self, idx: int):
        return self.query_results[idx]
    
    def __len__(self):
        return len(self.query_results)
    
    def valid_results(self):
        for result in self.query_results:
            if not result.internal.removed:
                yield result
    
    def enumerate_query_results(self, skip_removed=True):
        for i, result in enumerate(self.query_results):
            if skip_removed:
                if not result.internal.removed:
                    yield (i, result)
            else:
                yield (i, result)
    
    @model_validator(mode='after')
    def _fill_internal(self):
        if not hasattr(self, 'internal'):
            self.internal = InteralData(
                                        removed=False, 
                                        removal_reason=None,      
                                        parent_id=None, 
                                        collection_id=None,
                                        iteration=None
                                    )
        
        if self.query_results is None:
            self.query_results = []
            
        if self.data is None:
            self.data = {}
            
        if self.id is None:
            self.id = f'query_{str(uuid.uuid1())}'
            
        return self
                
    @classmethod
    def from_item(cls, item: Item):
        query = cls(id=None, item=item.item, embedding=item.embedding, data=item.data, query_results=None)
        query.update_internal(parent_id=item.id, collection_id=item.internal.collection_id)
        return query
    
    @classmethod
    def from_parent_query(cls, embedding: List[float], parent_query):
        query = cls(id=None, item=None, embedding=embedding, data=None, query_results=None)
        query.update_internal(parent_id=parent_query.id, collection_id=parent_query.internal.collection_id)
        return query
    
    def add_query_results(self, query_results: List[Item]):
        parent_id = self.id
        collection_id = self.internal.collection_id
        iteration = self.internal.iteration
        for result in query_results:
            result.update_internal(parent_id=parent_id, collection_id=collection_id, iteration=iteration)
            self.query_results.append(result)
    
    def update_internal(self, **kwargs):
        self.internal.__dict__.update(kwargs)
        if (len(self.query_results)>0) and (len(list(self.valid_results()))==0):
            self.internal.__dict__.update({'removed':True, 'removal_reason':'all query results removed'})
            
    @classmethod
    def from_minimal(cls, id=None, item=None, embedding=None, data=None, query_results=None):
        return cls(id=None, item=item, embedding=embedding, data=data, query_results=query_results)

# %% ../nbs/00_schemas.ipynb 10
class Batch(BaseModel):
    queries: List[Query]
        
    def __iter__(self):
        return iter(self.queries)

    def __getitem__(self, idx: int):
        return self.queries[idx]
    
    def __len__(self):
        return len(self.queries)
    
    def get_item(self, query_index, result_index=None):
        if result_index is not None:
            return self.queries[query_index][result_index]
        else:
            return self.queries[query_index]
        
    def valid_queries(self):
        for query in self.queries:
            if not query.internal.removed:
                yield query
        
    def enumerate_queries(self, skip_removed=True):
        for i, query in enumerate(self.queries):
            if skip_removed:
                if not query.internal.removed:
                    yield ((i,None), query)
            else:
                yield ((i,None), query)
                
    def enumerate_query_results(self, skip_removed=True):
        for (i,_), query in self.enumerate_queries(skip_removed):
            for j, result in query.enumerate_query_results(skip_removed):
                yield ((i,j), result)

                
    def flatten_queries(self, skip_removed=True):
        idxs = []
        outputs = []
        for i, q in self.enumerate_queries(skip_removed):
            idxs.append(i)
            outputs.append(q)
        return idxs, outputs
                
    def flatten_query_results(self, skip_removed=True):
        idxs = []
        outputs = []
        for i, r in self.enumerate_query_results(skip_removed):
            idxs.append(i)
            outputs.append(r)
        return idxs, outputs

# %% ../nbs/00_schemas.ipynb 13
class DataSourceResponse(BaseModel):
    valid: bool
    data: Optional[Dict]
    query_results: List[Item]

# %% ../nbs/00_schemas.ipynb 14
DataSourceFunction = Callable[List[Query], List[DataSourceResponse]]

# %% ../nbs/00_schemas.ipynb 16
class FilterResponse(BaseModel):
    valid: bool
    data: Optional[dict]
        
    @model_validator(mode='before')
    @classmethod
    def _fill_data(cls, data: Any) -> Any:
        if "data" not in data:
            data["data"] = None
        return data

# %% ../nbs/00_schemas.ipynb 17
FilterFunction = Callable[List[Item], List[FilterResponse]]

# %% ../nbs/00_schemas.ipynb 19
class ScoreResponse(BaseModel):
    valid: bool
    score: Optional[float]
    data: Optional[dict]
        
    @model_validator(mode='before')
    @classmethod
    def _fill_data(cls, data: Any) -> Any:
        if "data" not in data:
            data["data"] = None
        return data

# %% ../nbs/00_schemas.ipynb 20
ScoreFunction = Callable[List[Item], List[ScoreResponse]]

# %% ../nbs/00_schemas.ipynb 22
class PruneResponse(BaseModel):
    valid: bool
    data: Optional[dict]
        
    @model_validator(mode='before')
    @classmethod
    def _fill_data(cls, data: Any) -> Any:
        if "data" not in data:
            data["data"] = None
        return data

# %% ../nbs/00_schemas.ipynb 23
PruneFunction = Callable[List[Query], List[PruneResponse]]

# %% ../nbs/00_schemas.ipynb 25
UpdateFunction = Callable[List[Query], List[Query]]
