# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_prune.ipynb.

# %% auto 0
__all__ = ['PruneModule', 'PrunePlugin', 'TopKPrune']

# %% ../nbs/07_prune.ipynb 3
from .imports import *
from .module import Module
from .schemas import Item, Query, Batch, PruneFunction, PruneResponse

# %% ../nbs/07_prune.ipynb 5
class PruneModule(Module):
    def __init__(self,
                 function: PruneFunction # prune function
                ):
        super().__init__(PruneResponse, function)
        
    def gather_inputs(self, batch: Batch) -> (List[Tuple], List[Query]):
        idxs, inputs = batch.flatten_queries()
        return (idxs, inputs)
    
    def scatter_results(self, batch: Batch, idxs: List[Tuple], results: List[PruneResponse]):
        for (q_idx, r_idx), result in zip(idxs, results):
            batch_item = batch.get_item(q_idx, r_idx)
            if result.data:
                batch_item.data.update(result.data)

            if not result.valid:
                batch_item.update_internal(removed=True, removal_reason='prune response invalid')

# %% ../nbs/07_prune.ipynb 8
class PrunePlugin():
    '''
    PrunePlugin - documentation for plugin functions to `PruneFunction`
    
    A valid `PruneFunction` is any function that maps `List[Query]` to 
    `List[PruneResponse]`. The inputs will be given as `Query` objects. 
    The outputs can be either a list of `PruneResponse` objects or a list of 
    valid json dictionaries that match the `PruneResponse` schema
    
    The Prune step is called after scoring, so each result `Item` in the 
    input queries will have a score assigned
    
    Item schema:
    
    `{
        'id' : Optional[Union[str, int]]
        'item' : Optional[Any],
        'embedding' : List[float],
        'score' : float,
        'data' : Optional[Dict],
    }`
    
    
    Query schema:
    
    `{
        'item' : Optional[Any],
        'embedding' : List[float],
        'data' : Optional[Dict],
        'query_results': List[Item]
    }`
    
    Input schema:
    
    `List[Query]`
    
    PruneResponse schema:
    
    `{
        'valid' : bool,
        'data' : Optional[Dict],
    }`
    
    Output schema:
    
    `List[PruneResponse]`
    
    '''
    def __call__(self, inputs: List[Query]) -> List[PruneResponse]:
        pass

# %% ../nbs/07_prune.ipynb 9
class TopKPrune():
    '''
    TopKPrune - keeps the top `k` best queries in each group 
    by aggregated score
    
    queries are first grouped by `group_by`
    * if `group_by=None`, all queries are considered the same group (global pruning)
    * if `group_by='parent_id'`, queries are grouped by parent query id
    * if `group_by='collection_id', queries are grouped by collection id
    
    queries are then assigned a score based on aggregating query result scores
    * if `score_agg='mean'`, each `Query` is scored by the average score of all `Item` results
    * if `score_agg='max'`, each `Query` is scored by the max scoring `Item` result
    '''
    def __init__(self,
                 k: int,
                 score_agg: str='mean', # ['mean', 'max']
                 group_by: Optional[str]='collection_id' # [None, 'collection_id', 'parent_id']
                ):
        self.k = k
        self.score_agg = score_agg
        self.group_by = group_by
        
        assert self.score_agg in ['mean', 'max']
        assert self.group_by in [None, 'collection_id', 'parent_id']
        
    def agg_scores(self, query: Query):
        result_scores = np.array([i.score for i in query.valid_results()])
        if self.score_agg == 'mean':
            result_scores = result_scores.mean()
        elif self.score_agg == 'max':
            result_scores = result_scores.max()
        return result_scores
    
    def get_group_key(self, query: Query):
        key = None
        if self.group_by == 'collection_id':
            key = query.internal.collection_id
        elif self.group_by == 'parent_id':
            key = query.internal.parent_id
        return key
        
    def prune_queries(self, queries: List[Query]) -> List[PruneResponse]:
        scores = []
        for query in queries:
            scores.append(self.agg_scores(query))
            
        scores = np.array(scores)
        topk_idxs = set(scores.argsort()[::-1][:self.k])
        
        outputs = [PruneResponse(valid=(i in topk_idxs), data={f'{self.score_agg}_score':scores[i]})
                  for i in range(len(queries))]
        
        return outputs
    
    def group_queries(self, queries: List[Query]) -> (dict, dict):
        query_groups = defaultdict(list)
        idx_groups = defaultdict(list)
        
        for query_idx, query in enumerate(queries):
            key = self.get_group_key(query)
            query_groups[key].append(query)
            idx_groups[key].append(query_idx)
            
        return idx_groups, query_groups
    
    def scatter_queries(self, 
                        idx_groups: dict, 
                        query_groups: dict, 
                        total_queries: int)  -> List[PruneResponse]:
        
        outputs = [None for i in range(total_queries)]
        
        for key, query_list in query_groups.items():
            prune_results = self.prune_queries(query_list)
            scatter_idxs = idx_groups[key]
            
            for i, result in enumerate(prune_results):
                outputs[scatter_idxs[i]] = result
                
        return outputs
    
    def __call__(self, queries: List[Query]) -> List[PruneResponse]:
        idx_groups, query_groups = self.group_queries(queries)
        results = self.scatter_queries(idx_groups, query_groups, len(queries))
        return results
