# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_prune.ipynb.

# %% auto 0
__all__ = ['PruneModule', 'TopKPrune']

# %% ../nbs/06_prune.ipynb 3
from .imports import *
from .core import Module
from .schemas import Item, Query, Batch, PruneFunction, PruneResponse

# %% ../nbs/06_prune.ipynb 4
class PruneModule(Module):
    def __init__(self,
                 function: PruneFunction,
                ):
        super().__init__(PruneResponse, function)
        
    def gather_inputs(self, batch: Batch) -> (List[Tuple], List[Query]):
        idxs, inputs = batch.flatten_queries()
        return (idxs, inputs)
    
    def scatter_results(self, batch: Batch, idxs: List[Tuple], results: List[PruneResponse]):
        for (q_idx, r_idx), result in zip(idxs, results):
            batch_item = batch.get_item(q_idx, r_idx)
            if result.data:
                batch_item.data.update(result.data)

            if not result.valid:
                batch_item.data['_internal']['remove'] = True
                batch_item.data['_internal']['remove_details'] = 'prune result invalid'

# %% ../nbs/06_prune.ipynb 6
class TopKPrune():
    def __init__(self,
                 k: int,
                 agg: str='mean',
                 local: bool=True
                ):
        self.k = k
        self.agg = agg
        self.local = local
        assert agg in ['mean', 'max']
        
    def prune_queries(self, queries: List[Query]) -> List[PruneResponse]:
        scores = [np.array([j.score for j in i]) for i in queries]
        
        if self.agg=='mean':
            scores = np.array([i.mean() for i in scores])
        elif self.agg=='max':
            scores = np.array([i.max() for i in scores])
            
        topk_idxs = set(scores.argsort()[::-1][:self.k])
        
        outputs = [PruneResponse(valid=(i in topk_idxs), data={f'{self.agg}_score':scores[i]})
                  for i in range(len(queries))]
        
        return outputs
    
    def local_prune(self, queries: List[Query]) -> List[PruneResponse]:
        query_groups = defaultdict(list)
        idx_groups = defaultdict(list)
        
        outputs = [None for i in queries]
        
        for i, query in enumerate(queries):
            collection_index = query.data['_internal'].get('collection_index', -1)
            query_groups[collection_index].append(query)
            idx_groups[collection_index].append(i)
            
        for collection_idx, query_list in query_groups.items():
            prune_results = self.prune_queries(query_list)
            scatter_idxs = idx_groups[collection_idx]
            
            for i, result in enumerate(prune_results):
                outputs[scatter_idxs[i]] = result
                
        return outputs
    
    def __call__(self, queries: List[Query]) -> List[PruneResponse]:
        if self.local:
            outputs = self.local_prune(queries)
        else:
            outputs = self.prune_queries(queries)
            
        return outputs
