# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_utils.ipynb.

# %% auto 0
__all__ = ['whiten', 'pack_dataset', 'pack_dataframe', 'compute_rl_grad']

# %% ../nbs/00_utils.ipynb 3
from .imports import *

# %% ../nbs/00_utils.ipynb 4
def whiten(scores: np.ndarray # vector shape (n,) of scores to whiten
          ) -> np.ndarray: # vector shape (n,) whitened scores
    'Whitens vector of scores'
    mean = scores.mean()
    var = scores.var()
    
    return (scores - mean) / np.sqrt(var + 1e-8)

# %% ../nbs/00_utils.ipynb 5
def pack_dataset(dataset: Dataset, # input dataset
                 index_column: str, # name of column to group by
                 pack_columns: list[str] # columns to include in packing
                ) -> dict: 
    '''
    "packs" values in `pack_columns` by grouping them by the 
    distinct values in `index_column`
    
    returns a dictionary where the keys are the distinct values 
    in `index_column` and the values are a dictionary mapping 
    column names in `pack_columns` to the grouped values
    '''
    output = defaultdict(lambda: defaultdict(list))
    
    for row in dataset:
        for col_name in pack_columns:
            output[row[index_column]][col_name].append(row[col_name])
            
    return output

# %% ../nbs/00_utils.ipynb 6
def pack_dataframe(df: pd.DataFrame, # input dataframe
                 index_column: str, # name of column to group by
                 pack_columns: list[str] # columns to include in packing
                ) -> dict: 
    '''
    "packs" values in `pack_columns` by grouping them by the 
    distinct values in `index_column`
    
    returns a dictionary where the keys are the distinct values 
    in `index_column` and the values are a dictionary mapping 
    column names in `pack_columns` to the grouped values
    '''
    output = defaultdict(lambda: defaultdict(list))
    
    for idx, row in df.iterrows():
        row = dict(row)
        for col_name in pack_columns:
            output[row[index_column]][col_name].append(row[col_name])
            
    return output

# %% ../nbs/00_utils.ipynb 7
def compute_rl_grad(query_vectors: np.ndarray, # query vectors
                    query_dataset: Dataset, # dataset with ['query_idx', 'embedding', 'score'] columns
                    distance_penalty: float # distance penalty
                   ) -> np.ndarray: # array of gradient vectors
    
        packed_dict = pack_dataset(query_dataset, 'query_idx', ['embedding', 'score'])
        advantage_grads = []
        distance_grads = []
        
        for query_idx in range(query_vectors.shape[0]):
            if len(packed_dict[query_idx]['score'])>0:
                embs = np.array(packed_dict[query_idx]['embedding'])
                scores = np.array(packed_dict[query_idx]['score'])

                advantages = whiten(scores)
                advantage_grad = (advantages[:,None] * (2*(query_vectors[query_idx][None] - embs))).mean(0)
                
                distance_grad = 2*(query_vectors[query_idx] - embs.mean(0))
                
            else:
                # case where no results returned for vector
                advantage_grad = np.zeros(query_vectors[query_idx].shape)
                distance_grad = np.zeros(query_vectors[query_idx].shape)
                
            advantage_grads.append(advantage_grad)
            distance_grads.append(distance_grad)
            
        grads = np.array(advantage_grads) + (distance_penalty * np.array(distance_grads))

        return grads
