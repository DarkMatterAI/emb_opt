# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_score.ipynb.

# %% auto 0
__all__ = ['ScoreModule', 'ScorePlugin', 'CompositeScorePlugin']

# %% ../nbs/06_score.ipynb 3
from .imports import *
from .module import Module
from .schemas import Item, Query, Batch, ScoreFunction, ScoreResponse

# %% ../nbs/06_score.ipynb 5
class ScoreModule(Module):
    def __init__(self, 
                 function: ScoreFunction # score function
                ):
        super().__init__(ScoreResponse, function)
        
    def gather_inputs(self, batch: Batch) -> (List[Tuple], List[Item]):
        idxs, inputs = batch.flatten_query_results()
        return (idxs, inputs)
    
    def scatter_results(self, batch: Batch, idxs: List[Tuple], results: List[ScoreResponse]):
        for (q_idx, r_idx), result in zip(idxs, results):
            batch_item = batch.get_item(q_idx, r_idx)
            
            batch_item.score = result.score
            
            if result.data:
                batch_item.data.update(result.data)
                
            if not result.valid:
                batch_item.update_internal(removed=True, removal_reason='score response invalid')
                
        for _, result in batch.enumerate_query_results():
            if (result.score is None) and (not result.internal.removed):
                result.update_internal(removed=True, removal_reason='null score')
                
        for query in batch:
            query.update_internal()

# %% ../nbs/06_score.ipynb 7
class ScorePlugin():
    '''
    ScorePlugin - documentation for plugin functions to `ScoreFunction`
    
    A valid `ScoreFunction` is any function that maps `List[Item]` to
    `List[ScoreResponse]`. The inputs will be given as `Item` objects. 
    The outputs can be either a list of `ScoreResponse` objects or a list 
    of valid json dictionaries that match the `ScoreResponse` schema.
    
    Item schema:
    
    `{
        'id' : Optional[Union[str, int]]
        'item' : Optional[Any],
        'embedding' : List[float],
        'score' : None, # will be None at this stage
        'data' : Optional[Dict],
    }`
    
    Input schema:
    
    `List[Item]`
    
    ScoreResponse schema:

    `{
        'valid' : bool,
        'score' : Optional[float], # can be None if valid=False
        'data' : Optional[Dict],
    }`
    
    Output schema:
    
    `List[ScoreResponse]`
    
    '''
    def __call__(self, inputs: List[Item]) -> List[ScoreResponse]:
        pass

# %% ../nbs/06_score.ipynb 9
class CompositeScorePlugin():
    def __init__(self, 
                 functions: List[ScoreFunction] # list of score functions
                ):
        self.functions = functions
        
    def __call__(self, inputs: List[Item]) -> List[ScoreResponse]:
        results = [func(inputs) for func in self.functions]
        
        outputs = []
        
        for i in range(len(inputs)):
            data = {'score_results' : [result[i].model_dump() for result in results]}
            valid = all([result[i].valid for result in results])
            score = sum([result[i].score for result in results])
                
            outputs.append(ScoreResponse(valid=valid, score=score, data=data))
            
        return outputs
