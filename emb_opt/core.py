# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_core.ipynb.

# %% auto 0
__all__ = ['Executor', 'ProcessExecutor', 'ThreadExecutor', 'DatasetExecutor', 'Plugin']

# %% ../nbs/02_core.ipynb 3
from .imports import *
from .utils import batch_list, unbatch_list

# %% ../nbs/02_core.ipynb 4
class Executor():
    def __init__(self, 
                 batched: bool,
                 batch_size: int=1
                ):
        self.batched = batched
        self.batch_size = batch_size
    
    def batch_inputs(self, executor_inputs):
        if self.batched:
            executor_inputs = batch_list(executor_inputs, self.batch_size)
        return executor_inputs
            
    def unbatch_inputs(self, results):
        if self.batched:
            results = unbatch_list(results)
        return results
    
    def execute(self, executor_function, executor_inputs):
        results = [executor_function(i) for i in executor_inputs]
        return results
        
    def __call__(self, 
                 executor_function: Callable, 
                 executor_inputs: BaseModel,
                ) -> BaseModel:
        
        executor_inputs = self.batch_inputs(executor_inputs)
        results = self.execute(executor_function, executor_inputs)
        results = self.unbatch_inputs(results)
            
        return results

# %% ../nbs/02_core.ipynb 5
class ProcessExecutor(Executor):
    def __init__(self,
                 batched: bool,
                 batch_size: int=1,
                 concurrency: Optional[int]=1,
                ):
        self.batched = batched
        self.concurrency = concurrency
        self.batch_size = batch_size
        
    def execute(self, executor_function, executor_inputs):
        if (self.concurrency is None) or (self.concurrency==1):
            results = [executor_function(i) for i in executor_inputs]
        else:
            with ProcessPoolExecutor(min(self.concurrency, len(executor_inputs))) as p:
                results = list(p.map(executor_function, executor_inputs))
            
        return results
    
    def __call__(self, 
                 executor_function: Callable, 
                 executor_inputs: BaseModel,
                ) -> BaseModel:
        
        executor_inputs = self.batch_inputs(executor_inputs)
        results = self.execute(executor_function, executor_inputs)
        results = self.unbatch_inputs(results)
            
        return results

# %% ../nbs/02_core.ipynb 6
class ThreadExecutor(Executor):
    def __init__(self,
                 batched: bool,
                 concurrency: int=1,
                 batch_size: int=1,
                ):
        self.batched = batched
        self.concurrency = concurrency
        self.batch_size = batch_size
    
    def execute(self, executor_function, executor_inputs):
        if (self.concurrency is None) or (self.concurrency==1):
            results = [executor_function(i) for i in executor_inputs]
        else:
            with ThreadPoolExecutor(min(self.concurrency, len(executor_inputs))) as p:
                results = list(p.map(executor_function, executor_inputs))
            
        return results

# %% ../nbs/02_core.ipynb 7
class DatasetExecutor(Executor):
    def __init__(self,
                 output_schema: BaseModel,
                 batched: bool,
                 concurrency: Optional[int]=1,
                 batch_size: int=1,
                 map_kwargs: Optional[dict]=None
                ):
        self.output_schema = output_schema
        self.batched = batched
        self.concurrency = concurrency
        self.batch_size = batch_size
        self.map_kwargs = map_kwargs if map_kwargs else {}
        
    def execute(self, executor_function, executor_inputs):
        
        dataset = datasets.Dataset.from_list([i.model_dump() for i in executor_inputs])
        dataset = dataset.map(lambda row: executor_function(row), batched=self.batched, 
                             batch_size=self.batch_size, num_proc=self.concurrency, **self.map_kwargs)
        results = [self.output_schema(**i) for i in dataset.to_list()]
        return results
    
    def __call__(self, 
                 executor_function: Callable, 
                 executor_inputs: BaseModel
                ) -> BaseModel:
        results = self.execute(executor_function, executor_inputs)
        return results

# %% ../nbs/02_core.ipynb 9
class Plugin():
    def __init__(self, function: Callable, executor: Executor):
        self.function = function
        self.executor = executor
        
    def gather_inputs(self, inputs: BaseModel) -> BaseModel:
        raise NotImplementedError
        
    def scatter_results(self, inputs: BaseModel, results: BaseModel) -> BaseModel:
        raise NotImplementedError
        
    def __call__(self, inputs: BaseModel) -> BaseModel:
        
        function_inputs = self.gather_inputs(inputs)
        results = self.executor(self.function, function_inputs)
        outputs = self.scatter_results(inputs, results)
        return outputs
